<?php

namespace Celtic34fr\ContactRendezVous\Model;

use Celtic34fr\ContactCore\Entity\Clientele;
use Celtic34fr\ContactCore\Entity\CliInfos;
use Celtic34fr\ContactCore\Entity\Parameter;
use Celtic34fr\ContactCore\Enum\CustomerEnums;
use Celtic34fr\ContactCore\Enum\VisibiliteEnums;
use Celtic34fr\ContactRendezVous\Entity\CalEvent;
use Celtic34fr\ContactRendezVous\Entity\CompteRendu;
use Celtic34fr\ContactRendezVous\EntityRedefine\ParameterCalEvent;
use Celtic34fr\ContactRendezVous\Enum\StatusEnums;
use Celtic34fr\ContactRendezVous\Model\EventLocation;
use DateInterval;
use DateTime;
use DateTimeImmutable;
use DateTimeZone;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\EntityManagerInterface;

class EventICS
{
    private EntityManagerInterface $entityManager;

    private DateTime            $created_at;
    private DateTime            $lastupdated_at;
    private DateTime            $dateStart;
    private DateTime            $dateEnd;
    private string              $subject;
    private string              $details;
    private ?Parameter          $nature;
    private ?string             $bg_color = null;
    private ?string             $bd_color = null;
    private ?string             $tx_color = null;
    private bool                $allday;
    private string              $status;
    private Collection          $invite;
    private CompteRendu         $compte_rendu;
    private ?string             $uid = null;
    private ?string             $visibilite;
    private EventLocation       $location;
    private string              $fuseau_horaire;
    private ?EventRepetition    $frequence;

    public function __construct(EntityManagerInterface $entityManager, CalEvent $calEvent = null)
    {
        $this->entityManager = $entityManager;

        if ($calEvent) {
            $this->setCreatedAt($calEvent->getCreatedAt());
            $this->setLastupdatedAt($calEvent->getLastUpdated());
            $this->setDateStart($calEvent->getStartAt());
            $this->setDateEnd($calEvent->getEndAt());
            $this->setSubject($calEvent->getObjet());
            $this->setDetails($calEvent->getComplements());
            $this->setNature($calEvent->getNature());
            $this->setBgColor($calEvent->getBgColor());
            $this->setBdColor($calEvent->getBdColor());
            $this->setTxColor($calEvent->getTxColor());
            $this->setAllday($calEvent->getAllDay());
            $this->setStatus($calEvent->getStatus());
            foreach ($this->getInvites() as $invite) {
                $this->addInvite($invite);
            }
            $this->setCompteRendu($calEvent->getCompteRendu());
            $this->setUid($calEvent->getUid());
            $this->setLocation($calEvent->getLocation());
            /** affectation du fuseau horaire si DateStart ne l'a pas fait */
            if (!$this->getFuseauHoraire()) $this->setFuseauHoraire($calEvent->getFuseauHoraire());
            $this->setFrequence($calEvent->getFrequence());
        }
    }

    /**
     * Build CalendarICS object from array generated by IcsCalendarReader::load()
     *
     * @param array $calArray
     * @param string $globalFuseau
     * @return CalendarICS
     */
    public function buildFromArray(array $calArray, string $globalFuseau): EventICS
    {
        /** initialisatio du fuseau horaire local au global */
        $fuseau = $globalFuseau;

        $this->setUid($calArray['UID'] ?? "");
        $this->setSubject($calArray['SUMMARY']);
        $this->setDetails(array_key_exists('DESCRIPTION', $calArray) ? $calArray['DESCRIPTION'] : null);
        $this->setStatus(array_key_exists('STATUS', $calArray) ? $calArray['STATUS'] : "NEEDS-ACTION");

        $location = array_key_exists('LOCATION', $calArray) ? $calArray['LOCATION'] : null;
        if ($location && is_string($location)) $location = ["LOCATION" => $location];
        $location = new EventLocation([
            'LOCATION' => array_key_exists('LOCATION', $location) ? $location['LOCATION'] : null,
            'LATITUDE' => array_key_exists('LATITUDE', $location) ? $location['LATITUDE'] : null,
            'LONGITUDE' => array_key_exists('LONGITUDE', $location) ? $location['LONGITURE'] : null,
        ]);
        $this->setLocation($location);

        $dtStart = $this->extractDateMutable($calArray['DTSTART'], $globalFuseau);
        $this->setDateStart($dtStart);
        
        $created = array_key_exists('CREATED', $calArray) ? $this->extractDate($calArray['CREATED'], $globalFuseau) : new DateTime('now');
        $this->setCreatedAt($created);
        $lastUpdated = array_key_exists('LAST-MODIFIED', $calArray) ? $this->extractDate($calArray['LAST-MODIFIED'], $globalFuseau) : null;
        $this->setLastupdatedAt($lastUpdated);

        /** date de fin événement : DTEND ou DURATION ou rien */
        if (array_key_exists('DURATION', $calArray) && !array_key_exists('DTEND', $calArray)) {
            $dtEnd = $this->calcEndDate($dtStart, $calArray['DURATION']);
        } elseif (array_key_exists('DTEND', $calArray)) {
            $dtEnd = $this->extractDateMutable($calArray['DTEND'], $globalFuseau);
        } else {
            $dtEnd = $dtStart;
        }
        $this->setDateEnd($dtEnd);
        
        if (!$this->getFuseauHoraire() && $globalFuseau) $this->setFuseauHoraire($globalFuseau);

        $attendees = array_key_exists('ATTENDEE', $calArray) ? $calArray['ATTENDEE'] : [];
        if ($attendees) {
            /** traitement du tableau des personnes concernées par l'événement */
            foreach ($attendees as $attendee) {
                $this->addInvite($this->formatInvite($attendee));
            }
        }

        /* -> détermination du type d'événement par jour ou sur durée en fonction de DTSTART */
        $this->setAllday((int) $dtStart->format("His") == 0);

        return $this;
    }

    public function toCalEvent(CalEvent $calEvent = null) : CalEvent
    {
        if (!$calEvent) $calEvent = new CalEvent();
        $calEvent->setCreatedAt($this->getCreatedAt());
        $calEvent->setLastupdated($this->getLastUpdatedAt());
        $calEvent->setStartAt($this->getDateStart());
        $calEvent->setEndAt($this->getDateEnd());
        $calEvent->setObjet($this->getSubject());
        $calEvent->setComplements($this->getDetails());
        $calEvent->setNature($this->getNature());
        $calEvent->setBgColor($this->getBgColor());
        $calEvent->setBdColor($this->getBdColor());
        $calEvent->setTxColor($this->getTxColor());
        $calEvent->setAllday($this->isAllday());
        $calEvent->setStatus($this->getStatus());
        foreach ($this->getInvites() as $invite) {
            $calEvent->addInvite($invite);
        }
        $calEvent->setCompteRendu($this->getCompteRendu());
        $calEvent->setUid($this->getUid());
        $calEvent->setLocation($this->getLocation());
        $calEvent->setFuseauHoraire($this->getFuseauHoraire());
        return $calEvent;
    }

    /**
     * get date of Creation of Event
     * @return DateTime
     */
    public function getCreatedAt(): DateTime
    {
        return $this->created_at;
    }

    /**
     * set date of Creation of Event
     * @param array|DateTime|string $created_at
     * @return CalendarICS|bool
     */
    public function setCreatedAt(DateTime $created_at): self
    {
        if (is_array($created_at)) {
            $fuseau = $created_at['TZID'];
            $created_at = $created_at['VALUE'];
            $created_at = $this->extractDateMutable($created_at, $fuseau);
        } elseif (is_string($created_at)) {
            $dateStart = $this->extractDateMutable($created_at, $this->getFuseauHoraire());
        } elseif (!is_a($created_at, 'DateTime')) {
            return false;
        }
        $this->created_at = $created_at;
        if (empty($this->getDateStart()) && !empty($created_at->getTimezone())) {
            $this->setFuseauHoraire($created_at->getTimezone());
        }
        return $this;
    }

    /**
     * get date of Lsr Update of Event
     * @return DateTime
     */
    public function getLastupdatedAt(): DateTime
    {
        return $this->lastupdated_at;
    }

    /**
     * setDate of Last Update of Event
     * @param array|DateTime|string $lastupdated_at
     * @return CalendarICS|bool
     */
    public function setLastupdatedAt(DateTime $lastupdated_at): self
    {
        if (is_array($lastupdated_at)) {
            $fuseau = $lastupdated_at['TZID'];
            $lastupdated_at = $lastupdated_at['VALUE'];
            $lastupdated_at = $this->extractDateMutable($lastupdated_at, $fuseau);
        } elseif (is_string($lastupdated_at)) {
            $dateStart = $this->extractDateMutable($lastupdated_at, $this->getFuseauHoraire());
        } elseif (!is_a($lastupdated_at, 'DateTime')) {
            return false;
        }
        $this->lastupdated_at = $lastupdated_at;
        if (empty($this->getLastupdatedAt()) && !empty($lastupdated_at->getTimezone())) {
            $this->setFuseauHoraire($lastupdated_at->getTimezone());
        }
        return $this;
    }

    /**
     * get date when Start the Event
     * @return DateTime
     */
    public function getDateStart(): DateTime
    {
        return $this->dateStart;
    }

    /**
     * set date when Start the Event
     * @param array|DateTime|string $dateStart
     * @return CalendarICS|bool
     */
    public function setDateStart(mixed $dateStart): mixed
    {
        if (is_array($dateStart)) {
            $fuseau = $dateStart['TZID'];
            $dateStart = $dateStart['VALUE'];
            $dateStart = $this->extractDateMutable($dateStart, $fuseau);
        } elseif (is_string($dateStart)) {
            $dateStart = $this->extractDateMutable($dateStart, $this->getFuseauHoraire());
        } elseif (!is_a($dateStart, 'DateTime')) {
            return false;
        }
        $this->dateStart = $dateStart;
        if (!empty($dateStart->getTimezone())) {
            $this->setFuseauHoraire($dateStart->getTimezone());
        }
        return $this;
    }

    /**
     * get date when End the Event
     * @return DateTime
     */
    public function getDateEnd(): DateTime
    {
        return $this->dateEnd;
    }

    /**
     * set date when End the Event
     * @param array|DateTime|string $dateEnd
     * @return CalendarICS|bool
     */
    public function setDateEnd(DateTime $dateEnd): self
    {
        if (is_array($dateEnd)) {
            $fuseau = $dateEnd['TZID'];
            $dateEnd = $dateEnd['VALUE'];
            $dateEnd = $this->extractDateMutable($dateEnd, $fuseau);
        } elseif (is_string($dateEnd)) {
            $dateEnd = $this->extractDateMutable($dateEnd, $this->getFuseauHoraire());
        } elseif (!is_a($dateEnd, 'DateTime')) {
            return false;
        }
        $this->dateEnd = $dateEnd;
        if (empty($this->getDateStart()) && !empty($dateEnd->getTimezone())) {
            $this->setFuseauHoraire($dateEnd->getTimezone());
        }
       return $this;
    }

    /**
     * get the Object or Subject of the Event
     * @return string
     */
    public function getSubject(): string
    {
        return $this->subject;
    }

    /**
     * set the Object or Subject of the Event
     *
     * @param string $subject
     * @return CalendarICS
     */
    public function setSubject(string $subject): self
    {
        $this->subject = $subject;
        return $this;
    }

    /**
     * get the Details of the Event
     * @return string
     */
    public function getDetails(): string
    {
        return $this->details;
    }

    /**
     * set the Deatils of th Event
     * @param string $details
     * @return CalendarICS
     */
    public function setDetails(string $details): self
    {
        $this->details = $details;
        return $this;
    }

    /**
     * get the value of Nature of the Event
     * @return Parameter|null
     */
    public function getNature(): Parameter
    {
        return$this->nature;
    }

    /**
     * get the value of Nature's Description of the Event
     * @return string|null
     */
    public function getNatureDescription(): mixed
    {
        $nature = new ParameterCalEvent($this->nature);
        return $nature->getDescription();
    }

    /**
     * set the value of Nature of The Event (object Parameter, table Parameter)
     */
    public function setNature(Parameter $nature): self
    {
        $this->nature = $nature;
        return $this;
    }

    /**
     * get the Custom BackgroudColor associate at the Event
     * @return string|null
     */
    public function getBgColor(): ?string
    {
        return $this->bg_color;
    }

    /**
     * set the Custom backgroundColor associate at the Event
     * @param string|null $bg_color
     * @return CalendarICS
     */
    public function setBgColor(?string $bg_color): self
    {
        $this->bg_color = $bg_color;
        return $this;
    }

    /**
     * get the Custom BorderColor associate at the Event
     * @return string|null
     */
    public function getBdColor(): ?string
    {
        return $this->bd_color;
    }

    /**
     * set the Custom BorderColor associate at the Event
     * @param string|null $bd_color
     * @return CalendarICS
     */
    public function setBdColor(?string $bd_color): self
    {
        $this->bd_color = $bd_color;
        return $this;
    }

    /**
     * get the Custom TextColor associate at the Event
     * @return string|null
     */
    public function getTxColor(): ?string
    {
        return $this->tx_color;
    }

    /**
     * set the Custom TextColor associate at the Event
     * @param string|null $tx_color
     * @return CalendarICS
     */
    public function setTxColor(?string $tx_color): self
    {
        $this->tx_color = $tx_color;
        return $this;
    }

    /**
     * get Allday
     * @return bool
     */
    public function isAllday(): bool
    {
        return $this->allday;
    }

    /**
     * set Allday
     * @param bool $allday
     * @return CalendarICS
     */
    public function setAllday(bool $allday): self
    {
        $this->allday = $allday;
        return $this;
    }

    /**
     * get Status of the Event
     * @return string
     */
    public function getStatus(): string
    {
        return $this->status;
    }

    /**
     * set Status of the Event
     * @param string $status
     * @return CalendarICS|bool
     */
    public function setStatus(string $status): mixed
    {
        if (StatusEnums::isValid($status)) {
            $this->status = $status;
            return $this;
        }
        return false;
    }

    /**
     * get the Persons concerned by the Event
     * @return Collection|CliInfos[]|null
     */
    public function getInvites(): ?Collection
    {
        return $this->invite;
    }

    /**
     * add one Person concerned by the Event
     * @param CliInfos $invite
     * @return CalendarICS
     */
    public function addInvite(CliInfos $invite)
    {
        if (!$this->invite->contains($invite)) {
            $this->invite[] = $invite;
        }
        return $this;
    }

    /**
     * remove one Person concerned by the Event
     * @param CliInfos $invite
     * @return CalendarICS
     */
    public function removeInvite(CliInfos $invite)
    {
        $this->invite->removeElement($invite);
        return $this;
    }

    /**
     * get the Repport of Event (table CompteRendu)
     * @return CompteRendu
     */
    public function getCompteRendu(): CompteRendu
    {
        return $this->compte_rendu;
    }

    /**
     * set the Repport of Event (table CompteRendu)
     * @param CompteRendu|null $compte_rendu
     * @return CalendarICS
     */
    public function setCompteRendu(?CompteRendu $compte_rendu): self
    {
        $this->compte_rendu = $compte_rendu;
        return $this;
    }

    /**
     * get the Unique Identifier associate at the Event
     * @return string|null
     */
    public function getUid(): ?string
    {
        return $this->uid;
    }

    /**
     * set the Unique Identifier associate at the Event
     * @param string|null $uid
     * @return CalendarICS
     */
    public function setUid(?string $uid): self
    {
        $this->uid = $uid;
        return $this;
    }

    /**
     * get the Visibilite of the Event
     * @return string|null
     */
    public function getVisibilite(): ?string
    {
        return $this->visibilite;
    }

    /**
     * set the Visibilite of the Event
     * @param string|null $visibilite
     * @return CalendarICS|bool
     */
    public function setVisibilite(string $visibilite): mixed
    {
        if (VisibiliteEnums::isValid($visibilite)) {
            $this->visibilite = $visibilite;
            return $this;
        }
        return false;
    }

    /**
     * get the Location of the Event (object EventLocation)
     * @return EventLocation
     */
    public function getLocation(): EventLocation
    {
        return $this->location;
    }

    /**
     * set the Location of the Event (object EventLocation)
     * @param EventLocation $location
     * @return CalendarICS
     */
    public function setLocation(EventLocation $location): self
    {
        $this->location = $location;
        return $this;
    }

    /**
     * get Timezone for all Dates of the Event
     * @return string
     */
    public function getFuseauHoraire(): string
    {
        return $this->fuseau_horaire;
    }

    /**
     * set Timezone for all Dates of the Event
     * @param string $fuseau_horaire
     * @return CalendarICS
     */
    public function setFuseauHoraire(string $fuseau_horaire): self
    {
        /** affectation du fuseau horaire si DateStart vide ou si vide */
        if (empty($this->getDateStart()) || empty($this->getFuseauHoraire())) {
            $this->fuseau_horaire = $fuseau_horaire;
        } 
        return $this;
    }

        /**
     * extract date from line in ICS file
     * @param string|array $eventDate
     * @param string $fuseau
     * @return DateTime
     */
    private function extractDate(mixed $eventDate, string $fuseau): DateTimeImmutable
    {
        /**
         * format possible des dates :
         * 2014-06-12T20:00:00
         * 20140619T072445Z
         * array => VALUE / value => valeur à traiter : 20150211 / 20131220T130000
         * 
         * 1403086496 (timerstamp ?) ds DAYLIGHT bloc
         * 19700329T020000 das DAYLIGHT / STANDARD bloc
         */
        if (is_array($eventDate)) {
            /** recherche/extraction fuseau horaire local si trouvé sinon fuseau horaire global */
            $fuseau = array_key_exists('TZID', $eventDate) ? $eventDate['TZID'] : $fuseau;
            $value = $eventDate['VALUE'];
        } else {
            $value = $eventDate;
        }
        /** tranformation de la date pour obtenir un format : (YmdHis) */
        $value = trim($value);
        $value = str_replace(" ", "", $value);
        $value = str_replace("-", "", $value);
        $value = str_replace(":", "", $value);
        $value = str_replace("T", "", $value);
        $value = str_replace("Z", "", $value);
        if ($fuseau) { // si $fuseau non vide => gestion du fuseau horaine local / global
            $timezone = new DateTimeZone($fuseau);
            $dtStart = DateTimeImmutable::createFromFormat('YmdHis', $value, $timezone);
        } else { // heure du système
            $dtStart = DateTimeImmutable::createFromFormat('YmdHis', $value);
        }
        return $dtStart;
    }


    private function extractDateMutable(mixed $eventDate, string $fuseau)
    {
        if (empty($fuseau)) {
            $dateTime = new DateTime();
            $dateTime->setTimestamp($this->extractDate($eventDate, $fuseau)->getTimestamp());
        } else {
            $dateTime = new DateTime('', $this->extractDate($eventDate, $fuseau)->getTimezone());
            $dateTime->setTimestamp($this->extractDate($eventDate, $fuseau)->getTimestamp());
        }
        return $dateTime;
    }

    private function formatInvite(array $attendee): CliInfos
    {
        $invite = new CliInfos;

        /** recherche de la personne dans CliInfos / Clientele si existe */
        $calAttendee = $this->entityManager->getRepository(Clientele::class)
        ->findOneBy(['courriel' => $attendee['MAILTO']]);
        if (!$calAttendee && array_key_exists('CN', $attendee) && !empty($attendee['CN'])) 
            $calAttendee = $this->entityManager->getRepository(CliInfos::class)
            ->findFullname($attendee['CN']);

        // si la personne désignée n'existe pas dans CliInfo/Clientele : création en prospect
        if (!$calAttendee) {
            $clientele = new Clientele();
            $clientele->setCourriel($attendee['MAILTO']);
            $clientele->setType(CustomerEnums::Prospect->_toString());
            $this->entityManager->persist($clientele);

            $invite->setClient($clientele);
            if (!array_key_exists('CN', $attendee) || empty($attendee['CN'])) {
                $invite->setNom(uniqid("Prospect"));
            } else {
                $names = explode(' ', $attendee['CN']);
                if (empty($names[0])) {
                    $invite->setNom(uniqid("Prospect"));
                } else {
                    $invite->setNom($names[0]);
                    $invite->setPrenom($names[1]);
                }
            }
            $this->entityManager->persist($invite);
            $clientele->addCliInfos($invite);
        } else { // la personne existe => on a trouvé son email.
            if ($calAttendee instanceof CliInfos) {
                $invite = $calAttendee->getClient();
            } else {
                /** @var Clientele $calAttendee */
                if (!$calAttendee->isCliInfo(['fullname' => $attendee['CN']])) {
                    $invite->setClient($calAttendee);
                    $names = explode(' ', $attendee['CN']);
                    if (empty($names[0])) {
                        $invite->setNom(uniqid("Prospect"));
                    } else {
                        $invite->setNom($names[0]);
                        $invite->setPrenom($names[1]);
                    }
                    $this->entityManager->persist($invite);
                    $calAttendee->addCliInfos($invite);
                }
            }
        }
        $this->entityManager->flush();
        return $invite;
    }

    private function calcEndDate(DateTime $dtStart, string $duration) : DateTime
    {
        return $dtStart->add(new DateInterval($duration));;
    }

    /**
     * get the Frequence of the Event
     * @return EventRepetition|null
     */
    public function getFrequence(): ?EventRepetition
    {
        return $this->frequence;
    }

    /**
     * Set the value of frequence
     * @param array $rrule
     * @param ?string $globalFuseau
     * @return EventICS|bool
     */
    public function setFrequence(mixed $rrule, string $globalFuseau = null): mixed
    {
        if (is_array($rrule)) {
            // traitement des répétitions de l'événement
            $frequence = new EventRepetition();
            
            $freq = $rrule['FREQ'];
            $periodSet = ["", 'SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];
            $frequence->setPeriod(array_search($freq, $periodSet));

            $interval = array_key_exists('INTERVAL', $rrule) ? (int)$rrule['INTERVAL'] : 1;
            $frequence->setInterval($interval);

            $untilDate = null;
            if (array_key_exists('UNTIL', $rrule)) {
                $untilDate = $this->extractDate($rrule['UNTIL'], $globalFuseau);
            }
            $frequence->setUntilDate($untilDate);

            if (array_key_exists('COUNT', $rrule)) $frequence->setCount((int)$rrule['COUNT']);

            $this->frequence = $frequence;
            return $this;
        }
        return false;
    }
}